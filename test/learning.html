<html>
	<head>
		<script>		
/* checks if all examples give the same outcome
 */
var same_classification = function(examples) {
	var classification = examples[0].classification;
	for(var i in examples) {
		if (classification != examples[i].classification) return false;
	}
	return true;
};

/* returns the most frequent outcome
 */
var majority_value = function(examples) {
	var classifications = [];
	for(var i in examples) {
		if(typeof classifications[examples[i].classification] == 'undefined')
			classifications[examples[i].classification] = 1;
		else classifications[examples[i].classification]++;
	}
	var max = -1;
	var major;
	for(var i in classifications) {
		if(classifications[i] > max) { max = classifications[i]; major = i };
	}
	return major;
};

/* returns the array with one element removed
 */
var remove_attribute = function(attrib, to_remove) {
	var array = attrib.slice(0);
	for (var i=array.length-1; i>=0; i--) {
		if (array[i] === to_remove) {
			array.splice(i, 1);
		}
	}
	return array;
};

var base2_log = function(x) {
	return Math.log(x)/Math.log(2);
};

/* returns the entropy value.
 * total: number of total elements
 * partial: array with the frequency of each attribute value, for each attribute
 *          like: [attrib1 => ['yes' => 4, 'no' => 5], attrib2 => [...], ...]
 */
var entropy_array = function(partial, total) {
	var entropy = [];
	for(var a in partial) {
	entropy[a] = [];
		for(var v in partial[a]){
			entropy[a][v] = 0;
			for(var n in partial[a][v]) {
				entropy[a][v] += (-1) * base2_log((partial[a][v][n] / total));
			}
		}
	}
	return entropy;
};

/* selects the best attribute based on its entropy
 */
var index_of_best_value = function(entropy) {
	var min = 10; // entropy can be 0 at best
	var best = "";
	for(var a in entropy) {
		if(best == "") best = a;
		for(var v in entropy[a]) {
			if(entropy[a][v] <= min) {
				best = a;
				min = entropy[a][v];
			}
		}
	}
	return best;
};

/* returns an array that contains all the possible values corresponding to an example attribute.
 * both as key and value, like: ['yes' => 'yes', 'maybe' => 'maybe', ... ]
 */
var get_possible_values = function(attrib, examples) {
	var vals = [];
	for(var i in examples) {
		vals[examples[i][attrib]] = examples[i][attrib];
	}
	return vals;
};

/* returns an object, like
* {
*   name: attribute name,
*   values: array with all the possible values in examples for that attribute
* }
* */
var chose_attribute = function(attrib, examples) {
	var total = examples.length;
	var partial = [];  // will look like [attrib1 => ["yes" => 2, "no" => 1], ... ]
	for(var i in examples) {
		for(var j in attrib) {
			if(typeof partial[attrib[j]] == 'undefined') partial[attrib[j]] = [];
			if(typeof partial[attrib[j]][examples[i][attrib[j]]] == 'undefined') partial[attrib[j]][examples[i][attrib[j]]] = [];
			if(typeof partial[attrib[j]][examples[i][attrib[j]]][examples[i].classification] == 'undefined') partial[attrib[j]][examples[i][attrib[j]]][examples[i].classification] = 0;
			partial[attrib[j]][examples[i][attrib[j]]][examples[i].classification]++;
		}
	}
	var entropy = entropy_array(partial, total);
	var best = {"name": "", "values": []};
	best.name = index_of_best_value(entropy);
	best.values = get_possible_values(best.name, examples);

	return best;
};

/* returns an example list but only with the line corresponding to value in the attrib_name column
 */
var filter_based_on_attrib_value = function(value, attrib_name, examples) {
	var new_examples = [];
	for(var i in examples) {
		if(examples[i][attrib_name]==value)
			new_examples.push(examples[i]);
	}
	return new_examples;
};

/* Simple C4.5
 * examples: a list of examples from the learning set, like [{attrib1: x, attrib2: y, ... , classification}, ... ]
 * attrib: a list of attributes to choose from, like ["attrib1", "attrib2", ... ]
 * def: a default value if there are no examples (left), like "yes", or 1.
 *
 * returns: a classification tree, like
 * {
 *   "label": best attribute,
 *   "type": "parameter",
 *   "subtrees": [
 *                 {
 *                   "label": best attribute value i,
 *                   "type": "option",
 *                   "subtrees": [ { "type": "parameter", ... }, ... ],
 *                 },
 *                 {
 *                   "label": best attribute value i,
 *                   "type": "option",
 *                   "subtrees": [ { "label": classification, "type": "leaf", "subtrees": [] } ],
 *                 },
 *                   ...
 *               ],
 * }
 */
var c4_5_simple = function(examples, attrib, def) {
	var global_attrib = attrib; // c4.5 when a column is removed, it can't be reused for any call
	var c4_5_simple = function(examples, def) {
		if(examples.length == 0) return { "label": def, "type": "leaf", "subtrees": []};
		else if(same_classification(examples)) return { "label": examples[0].classification, "type": "leaf", "subtrees": [] };
		else if(global_attrib.length == 0) return { "label": majority_value(examples), "type": "leaf", "subtrees": []};
		else {
			var best = chose_attribute(global_attrib, examples);
			var tree = {"label": best.name, "subtrees": [], "type": "parameter"};
			var m = majority_value(examples);
			for(var i in best.values) {
				var examples_i = filter_based_on_attrib_value(best.values[i], best.name, examples);
				var new_attrib = remove_attribute(global_attrib, best.name);
				global_attrib = new_attrib;
				var subtree = {"label": best.values[i], "subtrees": [c4_5_simple(examples_i, new_attrib, m)], "type": "option"};
				tree.subtrees.push(subtree);
			}
			return tree;
		}
	};
	return c4_5_simple(examples, def);
};


/* PRISM
 * examples: a list of examples from the learning set, like [{attrib1: x, attrib2: y, ... , classification}, ... ]
 * attrib: a list of attributes to choose from, like ["attrib1", "attrib2", ... ]
 * def: a default value if there are no examples (left), like "yes", or 1.
 *
 * returns: a classification tree, like the one returned by c4_5_simple
 */
var prism_simple = function(examples, attrib, def) {
    if(examples.length == 0) return { "label": def, "type": "leaf", "subtrees": []};
    else if(same_classification(examples)) return { "label": examples[0].classification, "type": "leaf", "subtrees": [] };
    else if(attrib.length == 0) return { "label": majority_value(examples), "type": "leaf", "subtrees": []};
    else {
        var best = chose_attribute(attrib, examples);
        var tree = {"label": best.name, "subtrees": [], "type": "parameter"};
        var m = majority_value(examples);
        for(var i in best.values) {
            var examples_i = filter_based_on_attrib_value(best.values[i], best.name, examples);
            // no globally removed attribute in prism, only local for the call
            var new_attrib = remove_attribute(attrib, best.name);
            var subtree = {"label": best.values[i], "subtrees": [prism_simple(examples_i, new_attrib, m)], "type": "option"};
            tree.subtrees.push(subtree);
        }
        return tree;
    }
};


/* recursively clones an object
 */
function clone(obj) {
	var copy;

	// Handle the 3 simple types, and null or undefined
	if (null == obj || "object" != typeof obj) return obj;

	// Handle Date
	if (obj instanceof Date) {
		copy = new Date();
		copy.setTime(obj.getTime());
		return copy;
	}

	// Handle Array
	if (obj instanceof Array) {
		copy = [];
		for (var i = 0, len = obj.length; i < len; i++) {
			copy[i] = clone(obj[i]);
		}
		return copy;
	}

	// Handle Object
	if (obj instanceof Object) {
		copy = {};
		for (var attr in obj) {
			if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
		}
		return copy;
	}

	throw new Error("Unable to copy obj! Its type isn't supported.");
}
		
/* support function
 * recursively inspects the tree, taking decisions
 */
function classify(record, params) {
	var tree = params.tree;
	var val = params.val;
	var app;
	if(tree.type == "parameter") {
		var attrib = record[tree.label];
		for(var k in tree.subtrees){
			app = classify(record, {"tree": tree.subtrees[k], "val": attrib});
			if(app != null) return app;
		}
	}
	if(tree.type == "option" && tree.label == val) {
		for(var k in tree.subtrees){
			app = classify(record, {"tree": tree.subtrees[k], "val": null});
			if(app != null) return app;
		}
	}
	if(tree.type == "leaf") {
		return tree.label;
	}
	return null;
}

// TODO: test
/* given a new record and a classification tree,
 * returns the record with the classification value
 * a classification tree is like
 * {
 *   "label": best attribute,
 *   "type": "parameter",
 *   "subtrees": [
 *                 {
 *                   "label": best attribute value i,
 *                   "type": "option",
 *                   "subtrees": [ { "type": "parameter", ... }, ... ],
 *                 },
 *                 {
 *                   "label": best attribute value i,
 *                   "type": "option",
 *                   "subtrees": [ { "label": classification, "type": "leaf", "subtrees": [] } ],
 *                 },
 *                   ...
 *               ],
 *  }
 */
var classify_record = function(tree, new_record) {
	var record = clone(new_record);
	record.classification = classify(record, {"tree": tree, "val": null});
	return record;
};


/* given a learning set, a test set and an algorithms
 * returns the success rate of that algorithm on that test set
 */
var base_validation = function(learning_set, test_set, classification_algorithm){
    var attribs = Object.keys(test_set[0]);
    attribs = remove_attribute(attribs, "classification");
    var tree = classification_algorithm(learning_set, attribs, "");

    var generated_from_tests = [];
    var test_set_no_class = clone(test_set);

    var success = 0;
    var total = test_set.length;

    for(var i in test_set_no_class) {
        delete test_set_no_class[i]['classification'];
        generated_from_tests[i] = classify_record(tree, test_set_no_class[i]);

        if(generated_from_tests[i].classification == test_set[i].classification)
            success++;
    }
    test_set_no_class = null;

    return success/total;
};


/* given a full set of examples and an algorithms
 * returns the success rate of that algorithm on any learning/test partition based on the segment number
 *
 * calls base_validation multiple times, returning the average.
 * full example set is used, buth there is no peeking
 */
var cross_validation = function(examples, segment_number, classification_algorithm){
    var segment_size = Math.floor(examples.length/segment_number);
    var avg = 0;
    var calls = 0;
    var total = 0;
    for(var i = 0; i < examples.length; i+=segment_size) {
        var learning_set = examples.slice(0, i).concat(examples.slice(i+segment_size, examples.length)); //not taking the i-esim
        var test_set = examples.slice(i, i+segment_size);
        calls++;
        total += base_validation(learning_set, test_set, classification_algorithm);
    }
    return total/calls;
};


		</script>
		
	</head>
	<body>
	
	<div id="result"></div>
	
	
	<script>
function test_print(str) {
	document.getElementById('result').innerHTML += str + " <br />";
}

var test_examples = [
	{'attrib1': 'yes', 'attrib2': 'yes', 'attrib3': 'yes', 'classification': 'b'},
	{'attrib1': 'no', 'attrib2': 'no', 'attrib3': 'no', 'classification': 'b'},
	{'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'no', 'classification': 'b'}, 
	{'attrib1': 'yes', 'attrib2': 'yes', 'attrib3': 'no', 'classification': 'a'},
	{'attrib1': 'no', 'attrib2': 'yes', 'attrib3': 'yes', 'classification': 'a'},
	{'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'yes', 'classification': 'a'}, 
	{'attrib1': 'yes', 'attrib2': 'yes', 'attrib3': 'no', 'classification': 'a'},
	{'attrib1': 'no', 'attrib2': 'no', 'attrib3': 'yes', 'classification': 'b'}
];

var test_attrib = ['attrib1', 'attrib2', 'attrib3'];

test_print('same_classification: ' + same_classification(test_examples));
test_print('majority_value: ' + majority_value(test_examples)); 
test_print('remove_attribute: ' + remove_attribute(test_attrib, 'attrib2'));
test_print('test_attrib: ' + test_attrib);
test_print('chose_attribute: (1) in the console');	
console.log(1);
console.log(chose_attribute(test_attrib, test_examples));
test_print('filter_based_on_attrib_value: (2) in the console');	
console.log(2);
console.log(filter_based_on_attrib_value('yes', 'attrib1', test_examples));

test_print('c4_5_simple: (3) in the console');	
console.log(3);
var tree1 = c4_5_simple(test_examples, test_attrib, 'x');
console.log(tree1);

test_print('classify_record: (4) in the console');	
console.log(4);
console.log(classify_record(tree1, {'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'yes'})); // ok
console.log(classify_record(tree1, {'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'no'})); // wrong (c4.5 is not perfect)
console.log(classify_record(tree1, {'attrib1': 'no', 'attrib2': 'no', 'attrib3': 'yes'})); // ok


test_print('prism_simple: (5) in the console');	
console.log(5);
var tree2 = prism_simple(test_examples, test_attrib, 'x');
console.log(tree2);

test_print('classify_record: (6) in the console');	
console.log(6);
console.log(classify_record(tree2, {'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'yes'})); // ok
console.log(classify_record(tree2, {'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'no'})); // ok (prism is perfect)
console.log(classify_record(tree2, {'attrib1': 'no', 'attrib2': 'no', 'attrib3': 'yes'})); // ok

var test_set = [
					{'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'yes', "classification": "a"},
					{'attrib1': 'yes', 'attrib2': 'no', 'attrib3': 'no', "classification": "b"},
					{'attrib1': 'no', 'attrib2': 'no', 'attrib3': 'yes', "classification": "b"}
				];

test_print('base validation C4.5: ' + base_validation(test_examples, test_set, c4_5_simple));	
test_print('base validation PRISM: ' + base_validation(test_examples, test_set, prism_simple));

test_print('cross validation C4.5: ' + cross_validation(test_examples, 3, c4_5_simple));	
test_print('cross validation PRISM: ' + cross_validation(test_examples, 3, prism_simple));	

		</script>
	
	</body>

</html>